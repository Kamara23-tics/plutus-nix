<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Identity & Verifiable Credentials ‚Äî Contract Tutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{--bg:#fcfcfd;--muted:#6b7280;--ink:#0b2540;--card:#ffffff}
    body{font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--ink); margin:0; padding:28px}
    .container{max-width:980px;margin:0 auto}
    header{display:flex;align-items:center;gap:16px}
    header h1{margin:0;font-size:28px}
    header p{margin:0;color:var(--muted)}
    nav{margin:18px 0}
    nav a{display:inline-block;margin-right:14px;color:#0369a1;text-decoration:none}
    nav a:hover{text-decoration:underline}
    section{background:var(--card);border-radius:12px;padding:18px;margin-bottom:14px;box-shadow:0 6px 18px rgba(11,37,64,0.06)}
    h2{margin-top:0;color:#03203b}
    pre{background:#f6f8fb;padding:12px;border-radius:8px;overflow:auto}
    code{background:#eef2f7;padding:2px 6px;border-radius:6px}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{padding:8px;border:1px solid #e6eef6;text-align:left}
    .muted{color:var(--muted)}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>üîê Identity & Verifiable Credentials ‚Äî Contract Tutorial</h1>
        <p class="muted">A readable walkthrough of your Haskell/Plutus contract: data models, validator logic, helper functions, compilation & addresses, usage examples, testing advice and best practices.</p>
      </div>
    </header>

    <nav>
      <a href="#toc">Table of contents</a>
      <a href="#imports">Imports</a>
      <a href="#data">Data structures</a>
      <a href="#validator">Validator logic</a>
      <a href="#compile">Compilation & addresses</a>
      <a href="#usage">Usage examples</a>
      <a href="#testing">Testing</a>
      <a href="#best">Best practices</a>
    </nav>

    <section id="toc">
      <h2>üìö Table of contents</h2>
      <ol>
        <li><a href="#imports">Imports overview</a></li>
        <li><a href="#data">Data structures</a></li>
        <li><a href="#validator">Core validator logic</a></li>
        <li><a href="#helpers">Helper functions</a></li>
        <li><a href="#compile">Compilation, hash & addresses</a></li>
        <li><a href="#usage">Practical usage examples</a></li>
        <li><a href="#testing">Testing strategy</a></li>
        <li><a href="#best">Best practices</a></li>
        <li><a href="#glossary">Glossary</a></li>
      </ol>
    </section>

    <section id="imports">
      <h2>1. üì¶ Imports overview</h2>
      <p>This contract uses Plutus V2 on-chain APIs and a small set of utility modules for serialization and address conversion. Key groups:</p>
      <ul>
        <li><strong>Plutus on-chain:</strong> <code>Plutus.V2.Ledger.Api</code>, <code>Plutus.V2.Ledger.Contexts</code>.</li>
        <li><strong>Interval & Value helpers:</strong> <code>Plutus.V1.Ledger.Interval</code>, <code>Plutus.V1.Ledger.Value</code>.</li>
        <li><strong>PlutusTx:</strong> compilation and <code>unsafeFromBuiltinData</code> helpers.</li>
        <li><strong>Serialization & Cardano API:</strong> <code>Codec.Serialise</code>, <code>Cardano.Api</code> &amp; <code>Cardano.Api.Shelley</code> for bech32 addresses.</li>
      </ul>

      <p class="muted">Note: keep on-chain imports small. Anything used only off-chain (e.g., <code>Cardano.Api</code>) belongs in the off-chain/build-time binary.</p>
    </section>

    <section id="data">
      <h2>2. üßæ Data structures</h2>
      <p>Your contract defines a compact ‚Äî yet expressive ‚Äî set of on-chain datums. Here's a short summary.</p>

      <h3>VCRef (Verifiable Credential Reference)</h3>
      <p>Contains issuer, subject, schema &amp; data hashes, expiry/issued timestamps, revocation flag and credential type.</p>

      <h3>KYCBadge</h3>
      <p>Soul-bound token structure with holder, level, issuer, timestamps, jurisdiction and revocation metadata.</p>

      <h3>DIDDoc</h3>
      <p>DID document reference (controller, doc hash, key/service references, created/updated timestamps).</p>

      <h3>RevocationEntry &amp; ZKGate</h3>
      <p>Revocation entries are timestamped records. ZKGate config specifies required credential type, minimal KYC level, proof hash and verifier + trusted issuers.</p>

      <h3>IdentityDatum &amp; IdentityAction</h3>
      <p>Union datums (CredentialDatum | KYCBadgeDatum | DIDDatum | RevocationDatum | ZKGateDatum) and actions (Issue, Revoke, Update, Verify, Burn, AddRevocation).</p>
    </section>

    <section id="validator">
      <h2>3. üß† Core validator logic</h2>
      <p>The validator enforces role-based rules and state transitions. High-level rules per action:</p>
      <ul>
        <li><strong>IssueCredential:</strong> must be signed by issuer; credential must not already be revoked; expiry must be in future; UTxO must continue (credential locked).</li>
        <li><strong>RevokeCredential:</strong> only issuer may revoke; revocation must be recorded and added to revocation list UTxO.</li>
        <li><strong>IssueKYCBadge:</strong> signed by KYC issuer; KYC level between 1‚Äì5; badge non-revoked; badge must remain soul-bound (continuing output).</li>
        <li><strong>RevokeKYCBadge:</strong> signed by KYC issuer and marked revoked on the continued UTxO.</li>
        <li><strong>UpdateDID:</strong> only DID controller can update; new DID hash must change and timestamp must be newer.</li>
        <li><strong>VerifyWithZK:</strong> proof hash must match gate config and verifier must sign transaction; gate UTxO consumed after verification.</li>
        <li><strong>BurnKYCBadge:</strong> holder must sign and badge UTxO consumed.</li>
        <li><strong>AddRevocation:</strong> revocation entry must be added to the revocation list UTxO and signed by entry issuer.</li>
      </ul>

      <p>Key utilities used inside validator (already present in your code):</p>
      <pre><code>isExpired :: POSIXTime -> POSIXTimeRange -> Bool
isNotExpired :: POSIXTime -> POSIXTimeRange -> Bool
isTrustedIssuer :: PubKeyHash -> [PubKeyHash] -> Bool
isRevoked :: BuiltinByteString -> [RevocationEntry] -> Bool
meetsKYCLevel :: Integer -> Integer -> Bool
</code></pre>

      <p class="muted">Tip: keep heavy computations off-chain. The validator should perform simple checks and structural verifications to stay within size & execution limits.</p>
    </section>

    <section id="helpers">
      <h2>4. üîß Helper & view functions</h2>
      <p>Important small helpers in your code:</p>
      <ul>
        <li><code>getContinuingOutputs</code> to detect continued UTxOs.</li>
        <li>Pattern matched checks like <code>txSignedBy info pkh</code> to assert who signed the transaction.</li>
        <li>Datum sanity functions: you use <code>unsafeFromBuiltinData</code> ‚Äî okay on-chain but be mindful off-chain to provide correct datum shapes.</li>
        <li>Utility bools like <code>credentialLocked</code>, <code>badgeLocked</code>, <code>badgeBurned</code>.</li>
      </ul>

      <p>Keep helpers small and annotate them <code>{-# INLINABLE ... #-}</code> so the PlutusTx compiler can inline when necessary.</p>
    </section>

    <section id="compile">
      <h2>5. ‚öô Compilation, validator hash &amp; addresses</h2>
      <p>Your code compiles an untyped wrapper and builds a <code>Validator</code> via <code>mkValidatorScript</code>. You also implemented serialization and address conversion:</p>

      <pre><code>mkValidatorUntyped :: BuiltinData -> BuiltinData -> BuiltinData -> ()
validator :: Validator
plutusValidatorHash :: PlutusV2.Validator -> PlutusV2.ValidatorHash
plutusScriptAddress :: Address
toBech32ScriptAddress :: C.NetworkId -> Validator -> String
</code></pre>

      <p>Important notes:</p>
      <ul>
        <li><strong>Serialization:</strong> you serialise the validator for writing to <code>.plutus</code>. Keep the compiled bytes deterministic across builds.</li>
        <li><strong>Bech32:</strong> the provided <code>toBech32ScriptAddress</code> uses <code>Cardano.Api</code> and is appropriate for toolchain use (not on-chain).</li>
      </ul>
    </section>

    <section id="usage">
      <h2>6. üß™ Practical usage examples</h2>
      <p>Small examples you can run in the off-chain binary that you already have in <code>main</code>:</p>

      <pre><code>-- write validator to file
writeValidator "identity.plutus" validator

-- print addresses & hashes
let vh      = plutusValidatorHash validator
    onchain = plutusScriptAddress
    bech32  = toBech32ScriptAddress (C.Testnet (C.NetworkMagic 1)) validator

putStrLn $ "Validator Hash: " <> show vh
putStrLn $ "Script Address: " <> show onchain
putStrLn $ "Bech32 Address: " <> bech32
</code></pre>

      <p class="muted">Example flow: Issuer constructs a transaction that consumes the issuer output & produces a continuing UTxO containing <code>CredentialDatum</code>. The validator ensures the issuer signed and stored the right datum on-chain.</p>
    </section>

    <section id="testing">
      <h2>7. üß∑ Testing strategy</h2>
      <ul>
        <li><strong>Unit tests</strong> for every helper: <code>isNotExpired</code>, <code>isRevoked</code>, etc.</li>
        <li><strong>Property tests</strong> where possible: e.g., for revocation list invariants and timestamp monotonicity.</li>
        <li><strong>Trace-based integration tests</strong> using the Plutus emulator: simulate issuer, holder and verifier roles across flows (issue -> verify -> revoke).</li>
        <li><strong>Boundary cases:</strong> expiry exactly at the boundary, malicious attempts to replay UTxOs, missing datum shapes.</li>
      </ul>
    </section>

    <section id="best">
      <h2>8. ‚úÖ Best practices</h2>
      <ul>
        <li>Minimize on-chain storage: store hashes on-chain and keep full sensitive data off-chain (IPFS, secure storage).</li>
        <li>Use reference inputs where possible to avoid spending UTxOs for read-only checks.</li>
        <li>Prefer explicit revocation UTxO(s) with append-style semantics to reduce race conditions.</li>
        <li>Provide clear trace messages for each <code>traceIfFalse</code> check ‚Äî they help debugging emulator traces.</li>
        <li>Document every datum shape and redeemer expected by your off-chain code (wallets, dapps) so they produce correct datums.</li>
      </ul>
    </section>

    <section id="glossary">
      <h2>9. üìò Glossary</h2>
      <table>
        <tr><th>Term</th><th>Definition</th></tr>
        <tr><td>VC</td><td>Verifiable Credential ‚Äî signed credential referencing off-chain data via a hash.</td></tr>
        <tr><td>KYC Badge</td><td>Soul-bound token awarded by KYC providers; non-transferable.</td></tr>
        <tr><td>DID</td><td>Decentralized Identifier document referencing controller &amp; public keys.</td></tr>
        <tr><td>ZT Gate</td><td>Zero-knowledge gate ‚Äî verifies off-chain ZK proof via a proof hash &amp; verifier signature.</td></tr>
        <tr><td>Continuing UTxO</td><td>A UTxO produced by the consuming transaction that has the same script address (used to represent updated state).</td></tr>
      </table>
    </section>

    <footer style="text-align:center;margin-top:14px;color:var(--muted)">
      <small>Generated from your Haskell source ‚Äî feel free to edit, expand examples or request a PDF/README export.</small>
    </footer>
  </div>
</body>
</html>